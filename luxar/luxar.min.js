// Last time updated: 2023-11-9 1:37:15 AM UTC

// ________________

// Open-Sourced: https://github.com/ModrenCompany/ModrenPackages/tree/main/luxar

// '--------------------------------------------------'
// SurName: Mohamed Mustafa,
// Age: 13,
// Country: Egypt - EG,
// Location: Giza Haram kom a5dr tersa mareotya,
// Team often: 1,
// Helpers:
//  1 - ChatGPT - deepAI made by OpenAI / webLink: "https://chat.openai.com/?request=86h63-h4103-79k14?t=1",
//  2 - Clyde - a discord bot(AI) webLink: https://support.discord.com/hc/en-us/articles/13066317497239-Clyde-Discord-s-AI-Chatbot/,
//  3 - DeepAI - webLink: "https://deepai.org/chat/",
// Top:
//  1 - ChatGPT,
//  2 - DeepAI,
// 
// '--------------------------------------------------'
// Company: ModrenCompany \ MDC \ MD,
// VersionType: beta;
// '--------------------------------------------------'
// CopyRightÂ©

async function patcher(url) {
  const xhr = new XMLHttpRequest();
  xhr.open('GET', `"${url}"`, true);
  xhr.onload = function() {
    if (xhr.status === 200 && xhr.status === 300) {
      console.log(xhr.responseText);
    } else {
      console.error('Error:', xhr.status);
    }
  };
  xhr.onerror = function() {
    console.error('There was an error in the request.');
  };    
  xhr.send();
};
async function RandomUUID(len) {
  const crypto = require('crypto');
  return crypto.randomUUID().slice(0, len);
};
async function Mailer(data,user) {
    const nodemailer = require('nodemailer');

    const transporter = nodemailer.createTransport({
      service: `"${user.service}"`,
      auth: {
        user: `"${user.email}"`,
        pass: `"${user.pass}"`,
      },
    });

    const mailOptions = {
      from: `"${data.from}"`,
      to: `"${data.to}"`,
      subject: `"${data.subject}"`,
      text: `"${data.text}"`,
    };

    transporter.sendMail(mailOptions, (error, info) => {
      if (error) {
        console.error(error);
      } else {
        console.log('Email sent: ' + info.response);
      }
    });
};
async function Wardon(sv,level,err,combined) {
  const winston = require('winston');

  const logger = winston.createLogger({
    level: `"${level}"`,
    format: winston.format.json(),
    transports: [
      new winston.transports.File({ filename: `"${err.filename}"`, level: `"${err.level}"` }),
      new winston.transports.File({ filename: `"${combined}"` }),
    ],
  });

  logger.log({
    level: `"${level}"`,
    message: `"${sv}"`,
  });
};
class SmartStorageClass {
  constructor(data) {
    this.data = data || {};
  };

  async set(key, value) {
    this.data[key] = value;
  };

  async get(key) {
    return this.data[key] || null;
  };

  async remove(key) {
    if (key in this.data) {
      delete this.data[key];
    };
  };
};
class FileManager {
  constructor(directory) {
    this.directory = directory;
  }

  listFiles() {
    const fs = require('fs');
    const path = require('path');
    const files = fs.readdirSync(this.directory);
    return files;
  }

  createFile(filename, content) {
    const fs = require('fs');
    const path = require('path');
    const filePath = path.join(this.directory, filename);
    fs.writeFileSync(filePath, content);
  }

  readFile(filename) {
    const fs = require('fs');
    const path = require('path');
    const filePath = path.join(this.directory, filename);
    return fs.readFileSync(filePath, 'utf8');
  }

  deleteFile(filename) {
    const fs = require('fs');
    const path = require('path');
    const filePath = path.join(this.directory, filename);
    fs.unlinkSync(filePath);
  }
};
function NoteMe(config) {
  const { exec } = require('child_process');
  const notifier = require('node-notifier');
  notifier.notify({
    title:config.title,
    message:config.message,
    icon: config.icon,
    wait: config.wait,
    sound: config.sound,
  });
};
async function cellBackAPI(endpoint, method, data, url) {
  const axios = require('axios');
  try {
    const response = await axios({
      method,
      url: `https://${url}/${endpoint}`,
      data,
    });
    return response.data;
  } catch (error) {
    throw error;
  };
};
class WebServiceClient {
  constructor(baseURL) {
    this.baseURL = baseURL;
  }

  async get(url, params = {}) {
  const axios = require('axios');
    try {
      const response = await axios.get(`${this.baseURL}${url}`, { params });
      return response.data;
    } catch (error) {
      throw error;
    }
  }

  async post(url, data) {
    const axios = require('axios');
    try {
      const response = await axios.post(`${this.baseURL}${url}`, data);
      return response.data;
    } catch (error) {
      throw error;
    }
  }
};
class MathOperations {
  static add(a, b) {
    return a + b;
  }

  static subtract(a, b) {
    return a - b;
  }

  static multiply(a, b) {
    return a * b;
  }

  static divide(a, b) {
    if (b === 0) {
      throw new Error("It cannot be divided by zero");
    }
    return a / b;
  }
};
function RandomCode(length = 8, prefix = 'M.', suffix = '==') {
  const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789/M.';
  let result = prefix;

    for (let i = 0; i < length; i++) {
        const randomIndex = Math.floor(Math.random() * characters.length);
        result += characters.charAt(randomIndex);
    }

    result += suffix;

    return result;
}
class zArchiveClass {
  compressFile(inputFilePath, outputFilePath) {
    const zlib = require('zlib');
    const fs = require('fs');
    const input = fs.createReadStream(inputFilePath);
    const output = fs.createWriteStream(outputFilePath);
    const compress = zlib.createGzip();
    input.pipe(compress).pipe(output);
  };
  decompressFile(inputFilePath, outputFilePath) {
    const zlib = require('zlib');
    const fs = require('fs');
    const input = fs.createReadStream(inputFilePath);
    const output = fs.createWriteStream(outputFilePath);
    const decompress = zlib.createGunzip();
    input.pipe(decompress).pipe(output);
  };
};
function AnalyzeText(text) {
  const nlp = require('compromise');
  const doc = nlp(text);
  return {
    sentences: doc.sentences().out('array'),
    terms: doc.terms().out('array'),
    entities: doc.entities().out('array'),
  };
};
function MuRcPerformance(callback) {
  const now = require('performance-now');
  const start = now();
  callback();
  const end = now();
  const duration = end - start;

  console.log(`Execution time: ${duration.toFixed(3)} milliseconds`);
};

const SmartStorage = new SmartStorageClass();
const zArchive = zArchiveClass.prototype;


module.exports = {
  patcher,
  RandomUUID,
  Mailer,
  Wardon,
  SmartStorage,
  FileManager,
  NoteMe,
  cellBackAPI,
  WebServiceClient,
  MathOperations,
  RandomCode,
  zArchive,
  AnalyzeText,
  MuRcPerformance,
  Alerter,
};
